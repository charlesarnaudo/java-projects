import java.util.EmptyStackException;/** * A class that implements the ADT queue by using an expandable * circular array with one unused location. * * @author Frank M. Carrano * @author Timothy M. Henry * @author Charles Arnaudo * @version 4.0 */public final class ArrayQueue<T> implements QueueInterface<T> {    private T[] queue; // Circular array of queue entries and one unused location    private int frontIndex;    private int backIndex;    private int numberOfEntries;    private boolean initialized = false;    private static final int DEFAULT_CAPACITY = 50;    private static final int MAX_CAPACITY = 10000;    public ArrayQueue() {        this(DEFAULT_CAPACITY);    } // end default constructor    public ArrayQueue(int initialCapacity) {        checkCapacity(initialCapacity);        // The cast is safe because the new array contains null entries        @SuppressWarnings("unchecked")        T[] tempQueue = (T[]) new Object[initialCapacity + 1];        numberOfEntries = 0;        queue = tempQueue;        frontIndex = 0;        backIndex = initialCapacity;        initialized = true;    } // end constructor    private void checkCapacity(int initialCapacity) {        if (initialCapacity > MAX_CAPACITY) {            throw new IndexOutOfBoundsException();        }    }    private void ensureCapacity() {        if (frontIndex == ((backIndex + 2) % queue.length)) {            T[] oldQueue = queue;            int oldSize = oldQueue.length;            int newSize = 2 * oldSize;            checkCapacity(newSize);            //            T[] tempQueue = (T[]) new Object[newSize];            queue = tempQueue;            for (int i = 0; i < oldSize - 1; i++) {                queue[i] = oldQueue[frontIndex];                frontIndex = (frontIndex + 1) % oldSize;            }            frontIndex = 0;            backIndex = oldSize - 2;        }    }    private void checkInitialization() {        if (!initialized) {            throw new EmptyQueueException();        }    }//  < Implementations of the queue operations go here. >//  . . .    @Override    public void enqueue(T newEntry) {        checkInitialization();        ensureCapacity();        numberOfEntries++;        backIndex = (backIndex + 1) % queue.length;        queue[backIndex] = newEntry;    }    @Override    public T dequeue() {        checkInitialization();        if (isEmpty()) {            throw new EmptyQueueException();        } else {            numberOfEntries--;            T front = queue[frontIndex];            queue[frontIndex] = null;            frontIndex = (frontIndex + 1) % queue.length;            return front;        }    }    @Override    public T getFront() {        checkInitialization();        if (isEmpty()) {            throw new EmptyQueueException();        } else {            numberOfEntries--;            return queue[frontIndex];        }    }    @Override    public boolean isEmpty() {        return (numberOfEntries == 0);    }    @Override    public void clear() {        while (!isEmpty()) {            dequeue();        }    }} // end ArrayQueue