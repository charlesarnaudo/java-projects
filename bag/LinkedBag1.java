/** * Comp 2000: Data Structures, Fall, 2016 * * Charles Arnaudo * Assignment 1: Bag ADT * Due: 9/19/2016 */public final class LinkedBag1<T> implements BagInterface<T> {    private Node firstNode;       // Reference to first node    private int numberOfEntries;    public LinkedBag1() {        firstNode = null;        numberOfEntries = 0;    } // end default constructor    /**     * Adds a new entry to this bag.     *     * @param newEntry The object to be added as a new entry.     * @return True.     */    public boolean add(T newEntry) // OutOfMemoryError possible    {        // Add to beginning of chain:        Node newNode = new Node(newEntry);        newNode.next = firstNode;  // Make new node reference rest of chain        // (firstNode is null if chain is empty)        firstNode = newNode;       // New node is at beginning of chain        numberOfEntries++;        return true;    } // end add    /**     * Retrieves all entries that are in this bag.     *     * @return A newly allocated array of all the entries in this bag.     */    public T[] toArray() { // provided by instructor        {            @SuppressWarnings("unchecked")            T[] arrayOfStuff = (T[]) new Object[numberOfEntries];            copyLLToArray(arrayOfStuff);            return arrayOfStuff;        }    } // end toArray    public void printArray() {        T[] tempArray = toArray(); // makes an array        for (int i = 0; i < numberOfEntries; i++) { // prints out values in array followed by " "            System.out.print(tempArray[i] + " ");        }        System.out.println("\n"); // prints out blank line    }    private void copyLLToArray(T[] anArray) { // provided by instructor        Node aThing = firstNode;        for (int i = 0; i < numberOfEntries; i++) {            anArray[i] = aThing.data;            aThing = aThing.next;        }    }    /**     * Sees whether this bag is empty.     *     * @return True if the bag is empty, or false if not.     */    public boolean isEmpty() {        return numberOfEntries == 0;    } // end isEmpty    /**     * Gets the number of entries currently in this bag.     *     * @return The integer number of entries currently in the bag.     */    public int getCurrentSize() {        return numberOfEntries;    } // end getCurrentSize    /**     * Removes one unspecified entry from this bag, if possible.     *     * @return Either the removed entry, if the removal     * was successful, or null.     */    public T remove() {        if (!isEmpty()) { // only performs operation if bag is not empty            Node returnNode = firstNode; // saves node that is being removed            firstNode = firstNode.next; // moves chain down one            numberOfEntries--;            return (T) returnNode; // returns removed node        } else {            return null; // returns null if bag is empty        }    } // end remove    /**     * Locates a given entry within this bag. Returns a reference to the node     * containing the entry, if located, or null otherwise.     *     * @param anEntry given entry to get reference of     * @return Node containing the given entry     */    private Node getReferenceTo(T anEntry) {        boolean found = false;        Node currentNode = firstNode;        while (!found && (currentNode != null)) {            if (anEntry.equals(currentNode.data)) {                found = true;            } else {                currentNode = currentNode.next;            } // end if        } // end while        return currentNode;    } // end getReferenceTo    /**     * Removes one occurrence of a given entry from this bag.     *     * @param anEntry The entry to be removed.     * @return True if the removal was successful, or false otherwise.     */    public boolean remove(T anEntry) {        if (anEntry == null) {            return false;        }        boolean result = false;        Node nodeN = getReferenceTo(anEntry);        if (nodeN != null) {            nodeN.data = firstNode.data;            remove();            result = true;        } // end if        numberOfEntries--;        return result;    } // end remove    /**     * Removes all entries from this bag.     */    public void clear() {        if (!isEmpty()) { // only performs is bag is not empty            for (int i = 0; i < numberOfEntries; i++) { // runs through bag                remove(); // collapses            }        }    } // end clear    /**     * Counts the number of times a given entry appears in this bag.     *     * @param anEntry The entry to be counted.     * @return The number of times anEntry appears in the bag.     */    public int getFrequencyOf(T anEntry) {        Node currentNode = firstNode; // makes a copy of chain        int frequencyOf = 0; // counter is sad;        int x = 0;        for (int i = 0; i < numberOfEntries; i++) { // loops through chain            if (anEntry.equals(currentNode.data)) { // if anEntry is equal to currentNode, increment counter                frequencyOf++; // increment            }        }        return frequencyOf; // return result    } // end getFrequencyOf    /**     * Tests whether this bag contains a given entry.     *     * @param anEntry The entry to locate.     * @return True if the bag contains anEntry, or false otherwise.     */    public boolean contains(T anEntry) {        Node currentNode = firstNode; // makes a copy of the chain. Prevents destruction of chain        for (int i = 0; i < numberOfEntries; i++) { // runs through all entries in chain            if (anEntry.equals(currentNode.data)) { // checks contents of current node, returns true if equal                return true;            } else {                currentNode = currentNode.next;            }        }        return false;    } // end contains    private class Node {        private T data; // Entry in bag        private Node next; // Link to next node        private Node(T dataPortion) {            this(dataPortion, null);        } // end constructor        private Node(T dataPortion, Node nextNode) {            data = dataPortion;            next = nextNode;        } // end constructor    } // end Node} // end LinkedBag1